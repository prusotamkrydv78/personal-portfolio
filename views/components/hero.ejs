<section id="hero" class="relative min-h-screen flex items-center pt-20 overflow-hidden">
  <!-- 3D Background Canvas -->
  <canvas id="hero-canvas" class="absolute inset-0 w-full h-full"></canvas>

  <!-- Animated Gradient Orbs -->
  <div class="absolute inset-0 overflow-hidden pointer-events-none">
    <div class="absolute top-1/4 -left-20 w-80 h-80 bg-primary rounded-full opacity-10 filter blur-3xl pulse-slow"></div>
    <div class="absolute bottom-1/4 -right-20 w-80 h-80 bg-secondary rounded-full opacity-10 filter blur-3xl pulse-slow" style="animation-delay: 1s;"></div>
    <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-96 h-96 bg-accent rounded-full opacity-5 filter blur-3xl pulse-slow" style="animation-delay: 2s;"></div>
  </div>

  <!-- Grid Pattern Overlay -->
  <div class="absolute inset-0 bg-[url('/images/grid.svg')] bg-center opacity-5 pointer-events-none"></div>

  <div class="container mx-auto px-6 relative z-10 max-w-6xl">
    <!-- Hero Content Wrapper with Overlapping Design -->
    <div class="hero-content-wrapper relative">
      <!-- Text Content -->
      <div class="hero-text-content z-10 relative">
        <!-- Animated Badge -->
        <div class="inline-flex items-center px-3 py-1 rounded-full bg-primary bg-opacity-10 text-primary mb-6 reveal">
          <span class="animate-pulse mr-2">âœ¦</span>
          <span class="text-sm font-medium">Creative Web Developer</span>
        </div>

        <!-- Main Heading with Splitting.js animation -->
        <h1 class="hero-heading text-5xl md:text-7xl font-bold mb-6 font-display reveal" data-splitting>
          <span class="block">Hi, I'm <span class=" ext text-white">Prusotam</span></span>
          <span class="block text-3xl md:text-5xl mt-2 text-gray-400">I build <span id="typewriter" class="text-white"></span></span>
        </h1>

        <!-- Description -->
        <p class="text-xl text-gray-400 mb-8 max-w-xl reveal">
          A passionate web developer creating beautiful, interactive, and high-performance digital experiences with modern technologies.
        </p>

        <!-- CTA Buttons -->
        <div class="flex flex-wrap gap-4 reveal">
          <a href="#projects" class="btn-primary">
            <span class="btn-content">
              <span>View My Work</span>
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M12.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L14.586 11H3a1 1 0 110-2h11.586l-2.293-2.293a1 1 0 010-1.414z" clip-rule="evenodd" />
              </svg>
            </span>
            <span class="btn-glare"></span>
          </a>
          <a href="#contact" class="btn-secondary">
            <span class="btn-content">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                <path d="M2.003 5.884L10 9.882l7.997-3.998A2 2 0 0016 4H4a2 2 0 00-1.997 1.884z" />
                <path d="M18 8.118l-8 4-8-4V14a2 2 0 002 2h12a2 2 0 002-2V8.118z" />
              </svg>
              <span>Contact Me</span>
            </span>
          </a>
        </div>

        <!-- Social Links -->
        <div class="mt-10 flex items-center space-x-6 text-gray-400 reveal">
          <a href="https://github.com/prusotamydv" target="_blank" class="social-link" aria-label="GitHub">
            <i class="fab fa-github text-xl"></i>
          </a>
          <a href="https://linkedin.com/in/prusotam" target="_blank" class="social-link" aria-label="LinkedIn">
            <i class="fab fa-linkedin-in text-xl"></i>
          </a>
          <a href="mailto:your-email@example.com" class="social-link" aria-label="Email">
            <i class="fas fa-envelope text-xl"></i>
          </a>
          <span class="w-px h-6 bg-gray-700"></span>
          <a href="#contact" class="text-sm hover:text-primary transition-colors duration-300 flex items-center">
            <span>Let's Talk</span>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-1" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
            </svg>
          </a>
        </div>
      </div>

      <!-- Hero 3D Element -->
      <div class="hero-3d-wrapper">
        <div class="hero-3d-container">
          <!-- 3D Rotating Element -->
          <div id="hero-3d" class="hero-3d-element">
            <!-- Fallback Image (displays until 3D loads) -->
            <div class="hero-3d-fallback">
              <div class="hero-profile-wrapper">
                <!-- Removed rotating polygon -->
                <div class="hero-profile-container">
                  <img src="/images/profile.png" alt="Prusotam" class="hero-profile-image">
                </div>
              </div>
            </div>
          </div>

          <!-- Experience Badge -->
          <div class="hero-badge hero-badge-experience">
            <div class="hero-badge-icon hero-badge-icon-experience">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M6.267 3.455a3.066 3.066 0 001.745-.723 3.066 3.066 0 013.976 0 3.066 3.066 0 001.745.723 3.066 3.066 0 012.812 2.812c.051.643.304 1.254.723 1.745a3.066 3.066 0 010 3.976 3.066 3.066 0 00-.723 1.745 3.066 3.066 0 01-2.812 2.812 3.066 3.066 0 00-1.745.723 3.066 3.066 0 01-3.976 0 3.066 3.066 0 00-1.745-.723 3.066 3.066 0 01-2.812-2.812 3.066 3.066 0 00-.723-1.745 3.066 3.066 0 010-3.976 3.066 3.066 0 00.723-1.745 3.066 3.066 0 012.812-2.812zm7.44 5.252a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
              </svg>
            </div>
            <div>
              <div class="text-xs text-gray-400">Experience</div>
              <div class="font-medium text-white">2+ Years</div>
            </div>
          </div>

          <!-- Tech Stack Badge -->
          <div class="hero-badge hero-badge-tech">
            <div class="flex -space-x-2 mr-3">
              <div class="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-white text-xs font-bold">A</div>
              <div class="w-8 h-8 rounded-full bg-blue-400 flex items-center justify-center text-white text-xs font-bold">T</div>
              <div class="w-8 h-8 rounded-full bg-purple-500 flex items-center justify-center text-white text-xs font-bold">G</div>
            </div>
            <div>
              <div class="text-xs text-gray-400">Tech Stack</div>
              <div class="font-medium text-white">Modern</div>
            </div>
          </div>

          <!-- Floating Particles -->
          <div class="hero-particles"></div>
        </div>
      </div>
    </div>

    <!-- Scroll Down Indicator -->
    <div class="absolute bottom-10 left-1/2 transform -translate-x-1/2 flex flex-col items-center">
      <span class="text-sm text-gray-400 mb-2">Scroll Down</span>
      <div class="w-6 h-10 border-2 border-gray-700 rounded-full flex justify-center pt-1">
        <div class="w-1.5 h-1.5 bg-primary rounded-full animate-bounce"></div>
      </div>
    </div>
  </div>
</section>

<style>
  /* Hero Layout Styles */
  .hero-content-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: calc(100vh - 5rem);
    position: relative;
    overflow: visible;
  }

  /* Gradient Text Effect with Animation - Fixed */
  .gradient-text {
    background: linear-gradient(90deg,
      #6366f1, /* Primary */
      #ec4899, /* Secondary */
      #10b981, /* Green */
      #6366f1); /* Primary again */
    background-size: 300% 100%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    color: transparent;
    display: inline-block;
    position: relative;
    font-weight: bold;
    animation: gradientShift 8s ease infinite;
  }

  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }

  @media (min-width: 1024px) {
    .hero-content-wrapper {
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 2rem;
    }
  }

  /* Text Content Styles */
  .hero-text-content {
    width: 100%;
    max-width: 600px;
    margin-bottom: 3rem;
    position: relative;
  }

  @media (min-width: 1024px) {
    .hero-text-content {
      width: 50%;
      max-width: 550px;
      margin-bottom: 0;
      padding-right: 0;
      margin-left: 0;
    }
  }

  /* 3D Model Styles */
  .hero-3d-wrapper {
    width: 100%;
    display: flex;
    justify-content: center;
    position: relative;
  }

  @media (min-width: 1024px) {
    .hero-3d-wrapper {
      width: 45%;
      max-width: 500px;
      position: relative;
      right: auto;
      top: auto;
      transform: none;
    }
  }

  .hero-3d-container {
    position: relative;
    width: 320px;
    height: 320px;
    margin: 0 auto;
  }

  @media (min-width: 768px) {
    .hero-3d-container {
      width: 420px;
      height: 420px;
    }
  }

  .hero-3d-element {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .hero-3d-fallback {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .hero-profile-wrapper {
    position: relative;
    width: 280px;
    height: 280px;
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(236, 72, 153, 0.2), rgba(16, 185, 129, 0.2));
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0.5rem;
    animation: floating 6s ease-in-out infinite;
    box-shadow: 0 0 30px rgba(59, 130, 246, 0.2);
  }

  @media (min-width: 768px) {
    .hero-profile-wrapper {
      width: 340px;
      height: 340px;
    }
  }

  /* Removed hero-profile-glow styles */

  .hero-profile-container {
    position: relative;
    width: 100%;
    height: 100%;
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    overflow: hidden;
    border: 4px solid rgba(17, 24, 39, 0.8);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
  }

  .hero-profile-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Badge Styles */
  .hero-badge {
    position: absolute;
    background: rgba(17, 24, 39, 0.7);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    border-radius: 0.75rem;
    padding: 0.75rem 1rem;
    display: flex;
    align-items: center;
    z-index: 10;
    animation: fadeInUp 0.8s ease forwards;
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .hero-badge-experience {
    bottom: -1rem;
    right: -1rem;
    animation-delay: 0.6s;
  }

  .hero-badge-tech {
    top: -1rem;
    left: -1rem;
    animation-delay: 0.8s;
  }

  .hero-badge-icon {
    width: 2.5rem;
    height: 2.5rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 0.75rem;
  }

  .hero-badge-icon-experience {
    background-color: rgba(16, 185, 129, 0.2);
    border: 1px solid rgba(16, 185, 129, 0.3);
  }

  .hero-badge:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
    border-color: rgba(59, 130, 246, 0.3);
  }

  /* Floating Particles */
  .hero-particles {
    position: absolute;
    inset: -50px;
    pointer-events: none;
  }

  /* Animations */
  @keyframes floating {
    0%, 100% {
      transform: translateY(0);
    }
    50% {
      transform: translateY(-15px);
    }
  }

  /* Removed rotate animation */

  @keyframes fadeInUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* DOM Particles */
  .hero-particle {
    position: absolute;
    border-radius: 50%;
    pointer-events: none;
    z-index: 1;
  }

  @keyframes floatParticle {
    0% {
      transform: translate(0, 0) rotate(0deg);
    }
    25% {
      transform: translate(10px, -10px) rotate(90deg);
    }
    50% {
      transform: translate(20px, 0) rotate(180deg);
    }
    75% {
      transform: translate(10px, 10px) rotate(270deg);
    }
    100% {
      transform: translate(0, 0) rotate(360deg);
    }
  }

  /* Button Styles */
  .btn-primary, .btn-secondary {
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    font-weight: 500;
    overflow: hidden;
    transition: all 0.3s ease;
    z-index: 1;
  }

  .btn-primary {
    background: linear-gradient(90deg, var(--color-primary), var(--color-accent));
    color: white;
    box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4);
  }

  .btn-secondary {
    background: rgba(255, 255, 255, 0.05);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: white;
  }

  .btn-primary:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.5);
  }

  .btn-secondary:hover {
    transform: translateY(-3px) scale(1.05);
    background: rgba(255, 255, 255, 0.15);
    border-color: #3b82f6;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
  }

  .btn-content {
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
  }

  .btn-glare {
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle at center, rgba(255, 255, 255, 0.3) 0%, transparent 50%);
    transform: scale(0);
    opacity: 0;
    transition: transform 0.5s ease, opacity 0.5s ease;
    z-index: 0;
  }

  .btn-primary:hover .btn-glare {
    transform: scale(1);
    opacity: 1;
  }

  /* Social Link Hover Effect */
  .social-link {
    position: relative;
    display: inline-block;
    transition: all 0.3s ease;
  }

  .social-link::after {
    content: '';
    position: absolute;
    bottom: -5px;
    left: 0;
    width: 100%;
    height: 2px;
    background: linear-gradient(90deg, #3b82f6, #ec4899, #10b981);
    transform: scaleX(0);
    transform-origin: right;
    transition: transform 0.3s ease;
  }

  .social-link::before {
    content: '';
    position: absolute;
    inset: -8px;
    border-radius: 50%;
    background: radial-gradient(circle at center, rgba(59, 130, 246, 0.2) 0%, transparent 70%);
    opacity: 0;
    transform: scale(0.5);
    transition: all 0.3s ease;
  }

  .social-link:hover {
    color: white;
    transform: translateY(-2px) scale(1.1);
  }

  .social-link:hover::after {
    transform: scaleX(1);
    transform-origin: left;
  }

  .social-link:hover::before {
    opacity: 1;
    transform: scale(1);
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Typewriter effect
    const typewriterElement = document.getElementById('typewriter');
    const words = ['websites.', 'experiences.', 'interfaces.', 'applications.'];
    let wordIndex = 0;
    let charIndex = 0;
    let isDeleting = false;
    let typeSpeed = 100;

    function type() {
      const currentWord = words[wordIndex];

      if (isDeleting) {
        typewriterElement.textContent = currentWord.substring(0, charIndex - 1);
        charIndex--;
        typeSpeed = 50;
      } else {
        typewriterElement.textContent = currentWord.substring(0, charIndex + 1);
        charIndex++;
        typeSpeed = 150;
      }

      if (!isDeleting && charIndex === currentWord.length) {
        isDeleting = true;
        typeSpeed = 1500; // Pause at the end of the word
      } else if (isDeleting && charIndex === 0) {
        isDeleting = false;
        wordIndex = (wordIndex + 1) % words.length;
        typeSpeed = 500; // Pause before typing the next word
      }

      setTimeout(type, typeSpeed);
    }

    // Start the typewriter effect
    setTimeout(type, 1000);

    // 3D Background with Three.js
    function initThreeJsBackground() {
      const canvas = document.getElementById('hero-canvas');

      // Create scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);

      // Create particles
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 1500;
      const posArray = new Float32Array(particlesCount * 3);

      for (let i = 0; i < particlesCount * 3; i++) {
        posArray[i] = (Math.random() - 0.5) * 10;
      }

      particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

      // Create material
      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.02,
        color: 0x6366f1,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      });

      // Create mesh
      const particlesMesh = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particlesMesh);

      // Position camera
      camera.position.z = 3;

      // Mouse movement effect
      let mouseX = 0;
      let mouseY = 0;

      function onDocumentMouseMove(event) {
        mouseX = (event.clientX - window.innerWidth / 2) / 100;
        mouseY = (event.clientY - window.innerHeight / 2) / 100;
      }

      document.addEventListener('mousemove', onDocumentMouseMove);

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        particlesMesh.rotation.x += 0.0005;
        particlesMesh.rotation.y += 0.0005;

        // Respond to mouse movement
        particlesMesh.rotation.x += mouseY * 0.0005;
        particlesMesh.rotation.y += mouseX * 0.0005;

        renderer.render(scene, camera);
      }

      animate();
    }

    // Initialize 3D background
    initThreeJsBackground();

    // Create 3D rotating model for hero section
    function init3DHero() {
      const container = document.getElementById('hero-3d');

      // Create scene, camera, and renderer
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // Create a group to hold all objects
      const group = new THREE.Group();
      scene.add(group);

      // Create floating island base
      const islandGroup = new THREE.Group();
      group.add(islandGroup);

      // Create the main island platform
      const islandGeometry = new THREE.CylinderGeometry(1.8, 2.2, 0.5, 8);
      const islandMaterial = new THREE.MeshBasicMaterial({
        color: 0x1e293b, // Dark slate blue
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });
      const island = new THREE.Mesh(islandGeometry, islandMaterial);
      island.position.y = -0.8;
      islandGroup.add(island);

      // Add island bottom details
      const bottomGeometry = new THREE.ConeGeometry(1.5, 1.2, 8);
      const bottomMaterial = new THREE.MeshBasicMaterial({
        color: 0x0f172a, // Darker blue
        wireframe: true,
        transparent: true,
        opacity: 0.5
      });
      const bottom = new THREE.Mesh(bottomGeometry, bottomMaterial);
      bottom.position.y = -1.7;
      bottom.rotation.x = Math.PI; // Flip the cone
      islandGroup.add(bottom);

      // Create tech tree trunk
      const trunkGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1.5, 8);
      const trunkMaterial = new THREE.MeshBasicMaterial({
        color: 0x3b82f6, // Blue
        wireframe: false,
        transparent: true,
        opacity: 0.9
      });
      const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
      trunk.position.y = 0.2;
      islandGroup.add(trunk);

      // Create tech tree branches
      const createBranch = (startX, startY, startZ, endX, endY, endZ, thickness, color) => {
        // Calculate branch length and orientation
        const start = new THREE.Vector3(startX, startY, startZ);
        const end = new THREE.Vector3(endX, endY, endZ);
        const direction = new THREE.Vector3().subVectors(end, start);
        const length = direction.length();

        // Create branch geometry
        const branchGeometry = new THREE.CylinderGeometry(thickness * 0.8, thickness, length, 6);
        const branchMaterial = new THREE.MeshBasicMaterial({
          color: color,
          wireframe: false,
          transparent: true,
          opacity: 0.8
        });

        const branch = new THREE.Mesh(branchGeometry, branchMaterial);

        // Position and orient branch
        branch.position.copy(start);
        branch.position.addScaledVector(direction, 0.5);

        // Orient the branch to point in the direction
        branch.quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 1, 0),
          direction.clone().normalize()
        );

        return branch;
      };

      // Add main branches
      const branches = [];

      // Branch 1 - right up
      branches.push(createBranch(0, 0.6, 0, 0.8, 1.2, 0, 0.06, 0x3b82f6));

      // Branch 2 - left up
      branches.push(createBranch(0, 0.6, 0, -0.8, 1.0, 0.3, 0.06, 0x3b82f6));

      // Branch 3 - back up
      branches.push(createBranch(0, 0.8, 0, 0.3, 1.4, -0.7, 0.06, 0x3b82f6));

      // Add sub-branches
      // From branch 1
      branches.push(createBranch(0.8, 1.2, 0, 1.2, 1.5, 0.4, 0.04, 0xec4899));
      branches.push(createBranch(0.8, 1.2, 0, 1.0, 1.6, -0.3, 0.04, 0xec4899));

      // From branch 2
      branches.push(createBranch(-0.8, 1.0, 0.3, -1.2, 1.3, 0.6, 0.04, 0xec4899));
      branches.push(createBranch(-0.8, 1.0, 0.3, -1.1, 1.4, 0, 0.04, 0xec4899));

      // From branch 3
      branches.push(createBranch(0.3, 1.4, -0.7, 0.6, 1.7, -1.0, 0.04, 0xec4899));
      branches.push(createBranch(0.3, 1.4, -0.7, 0, 1.8, -1.1, 0.04, 0xec4899));

      // Add all branches to the island group
      branches.forEach(branch => islandGroup.add(branch));

      // Add tech nodes (connection points)
      const nodeGeometry = new THREE.SphereGeometry(0.08, 16, 16);
      const nodeMaterial1 = new THREE.MeshBasicMaterial({ color: 0x3b82f6 }); // Blue
      const nodeMaterial2 = new THREE.MeshBasicMaterial({ color: 0xec4899 }); // Pink
      const nodeMaterial3 = new THREE.MeshBasicMaterial({ color: 0x10b981 }); // Green

      // Create nodes at branch endpoints and junctions
      const nodes = [
        { pos: [0, 0.6, 0], material: nodeMaterial1, scale: 1.5 },
        { pos: [0.8, 1.2, 0], material: nodeMaterial1, scale: 1.2 },
        { pos: [-0.8, 1.0, 0.3], material: nodeMaterial1, scale: 1.2 },
        { pos: [0.3, 1.4, -0.7], material: nodeMaterial1, scale: 1.2 },
        { pos: [1.2, 1.5, 0.4], material: nodeMaterial2, scale: 1 },
        { pos: [1.0, 1.6, -0.3], material: nodeMaterial2, scale: 1 },
        { pos: [-1.2, 1.3, 0.6], material: nodeMaterial2, scale: 1 },
        { pos: [-1.1, 1.4, 0], material: nodeMaterial2, scale: 1 },
        { pos: [0.6, 1.7, -1.0], material: nodeMaterial2, scale: 1 },
        { pos: [0, 1.8, -1.1], material: nodeMaterial2, scale: 1 },
        { pos: [0, -0.5, 0], material: nodeMaterial3, scale: 1.3 }
      ];

      // Add all nodes
      nodes.forEach(nodeInfo => {
        const node = new THREE.Mesh(nodeGeometry, nodeInfo.material);
        node.position.set(...nodeInfo.pos);
        node.scale.set(nodeInfo.scale, nodeInfo.scale, nodeInfo.scale);
        islandGroup.add(node);
      });

      // Add floating data cubes around the tree
      const cubeGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
      const cubeMaterial = new THREE.MeshBasicMaterial({
        color: 0x10b981, // Green
        wireframe: true,
        transparent: true,
        opacity: 0.7
      });

      // Create several floating cubes
      const cubes = [];
      for (let i = 0; i < 8; i++) {
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        const angle = (i / 8) * Math.PI * 2;
        const radius = 1.2 + Math.random() * 0.5;
        const height = 0.5 + Math.random() * 1.5;

        cube.position.set(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        );

        cube.rotation.set(
          Math.random() * Math.PI,
          Math.random() * Math.PI,
          Math.random() * Math.PI
        );

        // Store original position for animation
        cube.userData = {
          originalY: cube.position.y,
          phaseOffset: Math.random() * Math.PI * 2
        };

        cubes.push(cube);
        islandGroup.add(cube);
      }

      // Create energy particles - inner swirl
      const innerParticlesGeometry = new THREE.BufferGeometry();
      const innerParticlesCount = 1000;
      const innerPosArray = new Float32Array(innerParticlesCount * 3);
      const innerColorArray = new Float32Array(innerParticlesCount * 3);

      for (let i = 0; i < innerParticlesCount * 3; i += 3) {
        // Create a spiral pattern
        const angle = Math.random() * Math.PI * 2;
        const radius = 1.2 + Math.random() * 1.5;
        const height = (Math.random() - 0.5) * 2;

        innerPosArray[i] = radius * Math.cos(angle);
        innerPosArray[i + 1] = height;
        innerPosArray[i + 2] = radius * Math.sin(angle);

        // Assign colors based on position (blue to pink gradient)
        const colorPos = Math.random();
        if (colorPos < 0.33) {
          // Blue
          innerColorArray[i] = 0.23; // R (59/255)
          innerColorArray[i + 1] = 0.51; // G (130/255)
          innerColorArray[i + 2] = 0.96; // B (246/255)
        } else if (colorPos < 0.66) {
          // Pink
          innerColorArray[i] = 0.93; // R (236/255)
          innerColorArray[i + 1] = 0.28; // G (72/255)
          innerColorArray[i + 2] = 0.60; // B (153/255)
        } else {
          // Green
          innerColorArray[i] = 0.06; // R (16/255)
          innerColorArray[i + 1] = 0.73; // G (185/255)
          innerColorArray[i + 2] = 0.51; // B (129/255)
        }
      }

      innerParticlesGeometry.setAttribute('position', new THREE.BufferAttribute(innerPosArray, 3));
      innerParticlesGeometry.setAttribute('color', new THREE.BufferAttribute(innerColorArray, 3));

      const innerParticlesMaterial = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      });

      const innerParticles = new THREE.Points(innerParticlesGeometry, innerParticlesMaterial);
      group.add(innerParticles);

      // Create outer aura particles
      const outerParticlesGeometry = new THREE.BufferGeometry();
      const outerParticlesCount = 1500;
      const outerPosArray = new Float32Array(outerParticlesCount * 3);

      for (let i = 0; i < outerParticlesCount * 3; i += 3) {
        const radius = 2.8 + Math.random() * 2;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;

        outerPosArray[i] = radius * Math.sin(phi) * Math.cos(theta);
        outerPosArray[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
        outerPosArray[i + 2] = radius * Math.cos(phi);
      }

      outerParticlesGeometry.setAttribute('position', new THREE.BufferAttribute(outerPosArray, 3));

      const outerParticlesMaterial = new THREE.PointsMaterial({
        size: 0.03,
        color: 0x3b82f6, // Blue
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending
      });

      const outerParticles = new THREE.Points(outerParticlesGeometry, outerParticlesMaterial);
      group.add(outerParticles);

      // Create a torus knot (complex knotted shape)
      const torusKnotGeometry = new THREE.TorusKnotGeometry(1.0, 0.3, 100, 16, 2, 3);
      const torusKnotMaterial = new THREE.MeshBasicMaterial({
        color: 0x3b82f6, // Blue
        wireframe: true,
        transparent: true,
        opacity: 0.4
      });
      const torusKnot = new THREE.Mesh(torusKnotGeometry, torusKnotMaterial);
      torusKnot.scale.set(0.8, 0.8, 0.8);
      torusKnot.position.set(0, 0, 0.5);
      group.add(torusKnot);

      // Create orbital rings
      const ringGeometry1 = new THREE.TorusGeometry(2.4, 0.02, 16, 100);
      const ringMaterial1 = new THREE.MeshBasicMaterial({
        color: 0x3b82f6, // Blue
        transparent: true,
        opacity: 0.3
      });
      const ring1 = new THREE.Mesh(ringGeometry1, ringMaterial1);
      ring1.rotation.x = Math.PI / 2;
      ring1.rotation.y = Math.PI / 6;
      group.add(ring1);

      const ringGeometry2 = new THREE.TorusGeometry(2.6, 0.02, 16, 100);
      const ringMaterial2 = new THREE.MeshBasicMaterial({
        color: 0xec4899, // Pink
        transparent: true,
        opacity: 0.2
      });
      const ring2 = new THREE.Mesh(ringGeometry2, ringMaterial2);
      ring2.rotation.x = Math.PI / 3;
      ring2.rotation.z = Math.PI / 4;
      group.add(ring2);

      // Add third ring
      const ringGeometry3 = new THREE.TorusGeometry(2.8, 0.02, 16, 100);
      const ringMaterial3 = new THREE.MeshBasicMaterial({
        color: 0x10b981, // Green
        transparent: true,
        opacity: 0.2
      });
      const ring3 = new THREE.Mesh(ringGeometry3, ringMaterial3);
      ring3.rotation.x = Math.PI / 4;
      ring3.rotation.z = Math.PI / 3;
      group.add(ring3);

      // Create energy beams
      const beamGroup = new THREE.Group();
      group.add(beamGroup);

      // Create 8 energy beams radiating from the center
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const length = 3 + Math.random() * 1.5;

        // Create beam geometry
        const beamGeometry = new THREE.CylinderGeometry(0.02, 0.02, length, 8, 1);

        // Determine beam color
        let beamColor;
        if (i % 3 === 0) beamColor = 0x3b82f6; // Blue
        else if (i % 3 === 1) beamColor = 0xec4899; // Pink
        else beamColor = 0x10b981; // Green

        const beamMaterial = new THREE.MeshBasicMaterial({
          color: beamColor,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });

        const beam = new THREE.Mesh(beamGeometry, beamMaterial);

        // Position and rotate the beam
        beam.position.set(
          Math.cos(angle) * (length / 2),
          0,
          Math.sin(angle) * (length / 2)
        );

        beam.rotation.z = Math.PI / 2;
        beam.rotation.y = angle;

        beamGroup.add(beam);
      }

      // Add energy orbs at beam endpoints
      const orbGroup = new THREE.Group();
      group.add(orbGroup);

      const orbGeometry = new THREE.SphereGeometry(0.12, 16, 16);
      const orbMaterial1 = new THREE.MeshBasicMaterial({
        color: 0x3b82f6,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      }); // Blue
      const orbMaterial2 = new THREE.MeshBasicMaterial({
        color: 0xec4899,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      }); // Pink
      const orbMaterial3 = new THREE.MeshBasicMaterial({
        color: 0x10b981,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
      }); // Green

      // Create orbs at different positions
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const radius = 2.8 + Math.random() * 0.5;
        const height = (Math.random() - 0.5) * 2;

        let orbMaterial;
        if (i % 3 === 0) orbMaterial = orbMaterial1;
        else if (i % 3 === 1) orbMaterial = orbMaterial2;
        else orbMaterial = orbMaterial3;

        const orb = new THREE.Mesh(orbGeometry, orbMaterial);
        orb.position.set(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        );

        // Store original position for animation
        orb.userData = {
          originalX: orb.position.x,
          originalY: orb.position.y,
          originalZ: orb.position.z,
          phaseOffset: Math.random() * Math.PI * 2
        };

        orbGroup.add(orb);
      }

      // Position camera
      camera.position.z = 5;

      // Mouse interaction - subtle following effect
      let mouseX = 0;
      let mouseY = 0;
      let targetX = 0;
      let targetY = 0;
      const windowHalfX = window.innerWidth / 2;
      const windowHalfY = window.innerHeight / 2;

      document.addEventListener('mousemove', (event) => {
        mouseX = (event.clientX - windowHalfX) / 200; // Reduced sensitivity
        mouseY = (event.clientY - windowHalfY) / 200; // Reduced sensitivity
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Smooth mouse following
        // targetX = mouseX * 0.3;
        // Subtle mouse following effect
        targetX = mouseX * 0.2;
        targetY = mouseY * 0.2;
        group.rotation.y += 0.002 + (targetX - group.rotation.y) * 0.02;
        group.rotation.x += 0.001 + (targetY - group.rotation.x) * 0.02;

        // Floating island animation
        islandGroup.position.y = Math.sin(Date.now() * 0.0005) * 0.1;

        // Animate tech nodes with a simpler approach
        for (let i = 0; i < islandGroup.children.length; i++) {
          const child = islandGroup.children[i];
          // Check if it's a node (sphere) by checking its geometry type
          if (child.geometry && child.geometry.type === 'SphereGeometry' && child.geometry.parameters.radius === 0.08) {
            // Apply pulsing effect
            const pulseScale = 1 + Math.sin(Date.now() * 0.001 + i * 0.5) * 0.15;
            child.scale.set(pulseScale, pulseScale, pulseScale);
          }

          // Check if it's a cube
          if (child.geometry && child.geometry.type === 'BoxGeometry') {
            // Rotation
            child.rotation.x += 0.01;
            child.rotation.y += 0.008;
            child.rotation.z += 0.005;

            // Floating movement if it has userData
            if (child.userData && child.userData.originalY) {
              child.position.y = child.userData.originalY +
                Math.sin(Date.now() * 0.001 + (child.userData.phaseOffset || 0)) * 0.1;
            }
          }
        }

        // Create energy particles for the tech tree
        if (!islandGroup.userData.particles) {
          // Create particle system for the tech tree
          const particlesGeometry = new THREE.BufferGeometry();
          const particlesCount = 300;
          const posArray = new Float32Array(particlesCount * 3);
          const colorArray = new Float32Array(particlesCount * 3);

          for (let i = 0; i < particlesCount * 3; i += 3) {
            // Create particles around the branches
            const angle = Math.random() * Math.PI * 2;
            const radius = 0.1 + Math.random() * 1.8;
            const height = Math.random() * 2 - 0.5;

            posArray[i] = radius * Math.cos(angle);
            posArray[i + 1] = height;
            posArray[i + 2] = radius * Math.sin(angle);

            // Assign colors
            if (Math.random() < 0.33) {
              // Blue
              colorArray[i] = 0.23;
              colorArray[i + 1] = 0.51;
              colorArray[i + 2] = 0.96;
            } else if (Math.random() < 0.66) {
              // Pink
              colorArray[i] = 0.93;
              colorArray[i + 1] = 0.28;
              colorArray[i + 2] = 0.60;
            } else {
              // Green
              colorArray[i] = 0.06;
              colorArray[i + 1] = 0.73;
              colorArray[i + 2] = 0.51;
            }
          }

          particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
          particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colorArray, 3));

          const particlesMaterial = new THREE.PointsMaterial({
            size: 0.03,
            vertexColors: true,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending
          });

          const particles = new THREE.Points(particlesGeometry, particlesMaterial);
          islandGroup.add(particles);

          // Store references for animation
          islandGroup.userData.particles = particles;
          islandGroup.userData.particlesGeometry = particlesGeometry;
        } else {
          // Animate existing particles
          const particles = islandGroup.userData.particles;
          const particlesGeometry = islandGroup.userData.particlesGeometry;

          // Rotate particles
          particles.rotation.y += 0.003;

          // Create wave effect
          const positions = particlesGeometry.attributes.position.array;
          const time = Date.now() * 0.0005;

          for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const z = positions[i + 2];
            const angle = Math.atan2(z, x);
            const distance = Math.sqrt(x * x + z * z);

            // Add subtle wave effect
            positions[i + 1] += (Math.sin(angle * 3 + time) * 0.001 +
                              Math.sin(distance * 2 - time * 2) * 0.001);

            // Keep particles within bounds
            if (positions[i + 1] > 2.5) positions[i + 1] = -0.5;
          }

          particlesGeometry.attributes.position.needsUpdate = true;
        }

        // Rotate the entire island group slightly
        islandGroup.rotation.y += 0.001;

        // Add energy rings around the island
        if (!islandGroup.userData.rings) {
          // Create orbital rings
          const ringGeometry1 = new THREE.TorusGeometry(2.4, 0.02, 16, 100);
          const ringMaterial1 = new THREE.MeshBasicMaterial({
            color: 0x3b82f6, // Blue
            transparent: true,
            opacity: 0.3
          });
          const ring1 = new THREE.Mesh(ringGeometry1, ringMaterial1);
          ring1.rotation.x = Math.PI / 2;
          ring1.rotation.y = Math.PI / 6;
          islandGroup.add(ring1);

          const ringGeometry2 = new THREE.TorusGeometry(2.6, 0.02, 16, 100);
          const ringMaterial2 = new THREE.MeshBasicMaterial({
            color: 0xec4899, // Pink
            transparent: true,
            opacity: 0.2
          });
          const ring2 = new THREE.Mesh(ringGeometry2, ringMaterial2);
          ring2.rotation.x = Math.PI / 3;
          ring2.rotation.z = Math.PI / 4;
          islandGroup.add(ring2);

          // Store references
          islandGroup.userData.rings = [ring1, ring2];
        } else {
          // Animate existing rings
          islandGroup.userData.rings[0].rotation.z += 0.003;
          islandGroup.userData.rings[1].rotation.y += 0.002;
        }

        renderer.render(scene, camera);
      }

      animate();

      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });

      // Create DOM particles
      createDOMParticles();
    }

    // Create DOM particles for additional visual effect
    function createDOMParticles() {
      const particlesContainer = document.querySelector('.hero-particles');
      if (!particlesContainer) return;

      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.className = 'hero-particle';

        // Random position
        const posX = Math.random() * 100;
        const posY = Math.random() * 100;

        // Random size
        const size = Math.random() * 6 + 1;

        // Random opacity
        const opacity = Math.random() * 0.5 + 0.2;

        // Random animation duration and delay
        const duration = Math.random() * 20 + 10;
        const delay = Math.random() * 5;

        // Apply styles
        const colorRandom = Math.random();
        let particleColor;

        if (colorRandom < 0.33) {
          particleColor = '#3b82f6'; // Blue
        } else if (colorRandom < 0.66) {
          particleColor = '#ec4899'; // Pink
        } else {
          particleColor = '#10b981'; // Green
        }

        particle.style.cssText = `
          left: ${posX}%;
          top: ${posY}%;
          width: ${size}px;
          height: ${size}px;
          opacity: ${opacity};
          animation: floatParticle ${duration}s linear infinite;
          animation-delay: -${delay}s;
          background-color: ${particleColor};
          box-shadow: 0 0 ${size * 2}px ${particleColor};
        `;

        particlesContainer.appendChild(particle);
      }
    }

    // Initialize 3D hero element
    init3DHero();
  });
</script>